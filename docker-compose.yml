# ============================================
# DOCKER COMPOSE - IA MONITOR
# ============================================
# Servicios de infraestructura local:
# - PostgreSQL: Base de datos principal
# - Redis: Cache + Broker para Celery

version: '3.8'

services:
  # ==========================================
  # POSTGRESQL 15
  # ==========================================
  postgres:
    image: postgres:15-alpine
    # Alpine = imagen ligera (~80MB vs ~250MB standard)

    container_name: iamonitor_postgres

    # Reiniciar automáticamente si falla
    restart: unless-stopped

    # Variables de entorno
    environment:
      # Usuario y contraseña de la BD
      # Lee desde .env o usa valores por defecto
      POSTGRES_USER: ${POSTGRES_USER:-iamonitor}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-iamonitor_dev_password}
      POSTGRES_DB: ${POSTGRES_DB:-iamonitor}

      # Configuración de PostgreSQL
      # Optimizada para 8GB RAM (conservadora)
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=es_ES.UTF-8"

    # Límites de recursos (importante con 8GB RAM)
    deploy:
      resources:
        limits:
          memory: 512M  # Máximo 512MB RAM
        reservations:
          memory: 256M  # Mínimo 256MB RAM

    # Volumen para persistir datos
    volumes:
      # postgres_data es un volumen nombrado (ver sección volumes: al final)
      - postgres_data:/var/lib/postgresql/data

      # (Opcional) Montar scripts de inicialización
      # - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql

    # Exponer puerto 5432
    ports:
      - "5433:5432"

    # Health check: Verificar que Postgres está listo
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-iamonitor}"]
      interval: 10s      # Verificar cada 10 segundos
      timeout: 5s        # Timeout si no responde en 5s
      retries: 5         # Intentar 5 veces antes de marcar como unhealthy
      start_period: 30s  # Esperar 30s antes del primer check

    # Red compartida con otros servicios
    networks:
      - iamonitor_network

  # ==========================================
  # REDIS 7
  # ==========================================
  redis:
    image: redis:7-alpine
    # Alpine = imagen ligera (~30MB)

    container_name: iamonitor_redis

    restart: unless-stopped

    # Comando de inicio con configuración optimizada
    command: >
      redis-server
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
      --appendonly yes
      --save 60 1
    # Explicación:
    # --maxmemory 256mb: Límite de RAM (suficiente para cache + queue)
    # --maxmemory-policy allkeys-lru: Eliminar claves menos usadas cuando se llena
    # --appendonly yes: Persistencia en disco (AOF log)
    # --save 60 1: Snapshot cada 60s si al menos 1 clave cambió

    # Límites de recursos
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

    # Volumen para persistir datos
    volumes:
      - redis_data:/data

    # Exponer puerto 6379
    ports:
      - "6379:6379"

    # Health check
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
      start_period: 10s

    networks:
      - iamonitor_network

  # ==========================================
  # PROMETHEUS 2.48
  # ==========================================
  prometheus:
    image: prom/prometheus:v2.48.0
    # Imagen oficial de Prometheus

    container_name: iamonitor_prometheus

    restart: unless-stopped

    # Comando de inicio con configuración personalizada
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=15d'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--web.enable-lifecycle'
    # Explicación:
    # --config.file: Archivo de configuración
    # --storage.tsdb.path: Directorio de almacenamiento de datos
    # --storage.tsdb.retention.time: Retención de 15 días
    # --web.enable-lifecycle: Permitir reload de config vía API

    # Límites de recursos
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M

    # Volúmenes
    volumes:
      # Configuración de Prometheus
      - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
      # Datos de Prometheus (time-series)
      - prometheus_data:/prometheus
      # (Opcional) Reglas de alerting
      # - ./prometheus/alert_rules.yml:/etc/prometheus/alert_rules.yml:ro

    # Exponer puerto 9090 (UI de Prometheus)
    ports:
      - "9090:9090"

    # Health check
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9090/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

    # Necesita acceso al host para scrapear FastAPI
    extra_hosts:
      - "host.docker.internal:host-gateway"

    networks:
      - iamonitor_network

  # ==========================================
  # GRAFANA 10.2
  # ==========================================
  grafana:
    image: grafana/grafana:10.2.0
    # Imagen oficial de Grafana OSS

    container_name: iamonitor_grafana

    restart: unless-stopped

    # Variables de entorno
    environment:
      # Credenciales de administrador
      # Lee desde .env o usa valores por defecto
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD:-admin}

      # Plugins adicionales (opcional)
      # GF_INSTALL_PLUGINS: redis-datasource

      # Configuración de servidor
      GF_SERVER_ROOT_URL: http://localhost:3000
      GF_SERVER_SERVE_FROM_SUB_PATH: "false"

      # Configuración de usuarios
      GF_USERS_ALLOW_SIGN_UP: "false"
      GF_USERS_ALLOW_ORG_CREATE: "false"

      # Configuración de logging
      GF_LOG_LEVEL: info
      GF_LOG_MODE: console

    # Límites de recursos
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

    # Volúmenes
    volumes:
      # Datos de Grafana (dashboards, usuarios, etc.)
      - grafana_data:/var/lib/grafana

      # Provisioning automático de datasources
      - ./grafana/provisioning/datasources:/etc/grafana/provisioning/datasources:ro

      # Provisioning automático de dashboards
      - ./grafana/provisioning/dashboards:/etc/grafana/provisioning/dashboards:ro

      # Dashboards en formato JSON
      - ./grafana/dashboards:/var/lib/grafana/dashboards:ro

    # Exponer puerto 3000 (UI de Grafana)
    ports:
      - "3000:3000"

    # Health check
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost:3000/api/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    # Depende de Prometheus
    depends_on:
      prometheus:
        condition: service_healthy

    networks:
      - iamonitor_network

# ==========================================
# VOLÚMENES NOMBRADOS
# ==========================================
# Ubicación real: /var/lib/docker/volumes/
volumes:
  postgres_data:
    # Persiste datos de PostgreSQL
    # Sobrevive a: docker-compose down
    # Se borra con: docker-compose down -v

  redis_data:
    # Persiste datos de Redis (AOF + snapshots)

  prometheus_data:
    # Persiste datos de Prometheus (time-series)
    # Retención: 15 días (configurable en command)

  grafana_data:
    # Persiste datos de Grafana (dashboards, configuraciones, usuarios)
    # Sobrevive a: docker-compose down
    # Se borra con: docker-compose down -v

# ==========================================
# RED COMPARTIDA
# ==========================================
networks:
  iamonitor_network:
    driver: bridge
    # Red tipo bridge: Containers se ven entre sí por nombre
    # Ejemplo: FastAPI puede conectar a postgres://postgres:5432
